var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@datastructures-js/queue/src/queue.js
var require_queue = __commonJS({
  "node_modules/@datastructures-js/queue/src/queue.js"(exports) {
    var Queue = class {
      /**
       * Creates a queue.
       * @param {array} [elements]
       */
      constructor(elements) {
        this._elements = Array.isArray(elements) ? elements : [];
        this._offset = 0;
      }
      /**
       * Adds an element to the back of the queue.
       * @public
       * @param {number|string|object} element
       */
      enqueue(element) {
        this._elements.push(element);
        return this;
      }
      /**
       * Adds an element to the back of the queue.
       * @public
       * @param {number|string|object} element
       */
      push(element) {
        return this.enqueue(element);
      }
      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        if (this.size() === 0)
          return null;
        const first = this.front();
        this._offset += 1;
        if (this._offset * 2 < this._elements.length)
          return first;
        this._elements = this._elements.slice(this._offset);
        this._offset = 0;
        return first;
      }
      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }
      /**
       * Returns the front element of the queue.
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this.size() > 0 ? this._elements[this._offset] : null;
      }
      /**
       * Returns the back element of the queue.
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this.size() > 0 ? this._elements[this._elements.length - 1] : null;
      }
      /**
       * Returns the number of elements in the queue.
       * @public
       * @returns {number}
       */
      size() {
        return this._elements.length - this._offset;
      }
      /**
       * Checks if the queue is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }
      /**
       * Returns the remaining elements in the queue as an array.
       * @public
       * @returns {array}
       */
      toArray() {
        return this._elements.slice(this._offset);
      }
      /**
       * Clears the queue.
       * @public
       */
      clear() {
        this._elements = [];
        this._offset = 0;
      }
      /**
       * Creates a shallow copy of the queue.
       * @public
       * @return {Queue}
       */
      clone() {
        return new Queue(this._elements.slice(this._offset));
      }
      /**
       * Creates a queue from an existing array.
       * @public
       * @static
       * @param {array} elements
       * @return {Queue}
       */
      static fromArray(elements) {
        return new Queue(elements);
      }
    };
    exports.Queue = Queue;
  }
});

// node_modules/@datastructures-js/queue/index.js
var require_queue2 = __commonJS({
  "node_modules/@datastructures-js/queue/index.js"(exports) {
    var { Queue } = require_queue();
    exports.Queue = Queue;
  }
});

// node_modules/@datastructures-js/stack/src/stack.js
var require_stack = __commonJS({
  "node_modules/@datastructures-js/stack/src/stack.js"(exports) {
    var Stack = class {
      /**
       * Creates a stack.
       * @param {array} [elements]
       */
      constructor(elements) {
        this._elements = Array.isArray(elements) ? elements : [];
      }
      /**
       * Checks if the stack is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._elements.length === 0;
      }
      /**
       * Returns the number of elements in the stack.
       * @public
       * @returns {number}
       */
      size() {
        return this._elements.length;
      }
      /**
       * Returns the top element in the stack.
       * @public
       * @returns {number|string|object}
       */
      peek() {
        if (this.isEmpty()) {
          return null;
        }
        return this._elements[this._elements.length - 1];
      }
      /**
       * Adds an element to the top of the stack.
       * @public
       * @param {number|string|object} element
       */
      push(element) {
        this._elements.push(element);
        return this;
      }
      /**
       * Removes and returns the top element in the stack.
       * @public
       * @returns {number|string|object}
       */
      pop() {
        if (this.isEmpty()) {
          return null;
        }
        return this._elements.pop();
      }
      /**
       * Returns the remaining elements as an array.
       * @public
       * @returns {array}
       */
      toArray() {
        return this._elements.slice();
      }
      /**
       * Clears all elements from the stack.
       * @public
       */
      clear() {
        this._elements = [];
      }
      /**
       * Creates a shallow copy from the stack.
       * @public
       * @return {Stack}
       */
      clone() {
        return new Stack(this._elements.slice());
      }
      /**
       * Creates a stack from an existing array
       * @public
       * @static
       * @param {array} [elements]
       * @return {Stack}
       */
      static fromArray(elements) {
        return new Stack(elements);
      }
    };
    exports.Stack = Stack;
  }
});

// node_modules/@datastructures-js/stack/index.js
var require_stack2 = __commonJS({
  "node_modules/@datastructures-js/stack/index.js"(exports) {
    var { Stack } = require_stack();
    exports.Stack = Stack;
  }
});

// node_modules/@datastructures-js/deque/src/deque.js
var require_deque = __commonJS({
  "node_modules/@datastructures-js/deque/src/deque.js"(exports) {
    var Deque = class {
      /**
       * Creates a deque
       * @param {array} [elements]
       */
      constructor(elements) {
        this._backElements = Array.isArray(elements) ? elements : [];
        this._frontElements = [];
        this._backOffset = 0;
        this._frontOffset = 0;
      }
      /**
       * Adds an element at the front of the queue
       * @public
       * @param {number|string|object} element
       */
      pushFront(element) {
        this._frontElements.push(element);
        return this;
      }
      /**
       * Adds an element at the back of the queue
       * @public
       * @param {number|string|object} element
       */
      pushBack(element) {
        this._backElements.push(element);
        return this;
      }
      /**
       * Dequeues the front element in the queue
       * @public
       * @returns {number|string|object}
       */
      popFront() {
        if (this.size() === 0) {
          return null;
        }
        if (this._frontElements.length > 0) {
          const front2 = this._frontElements.pop();
          if (this._frontOffset >= this._frontElements.length) {
            this._frontElements = this._frontElements.slice(this._frontOffset);
            this._frontOffset = 0;
          }
          return front2;
        }
        const front = this.front();
        this._backOffset += 1;
        if (this._backOffset * 2 < this._backElements.length) {
          return front;
        }
        this._backElements = this._backElements.slice(this._backOffset);
        this._backOffset = 0;
        return front;
      }
      /**
       * Dequeues the back element of the queue
       * @public
       * @returns {number|string|object}
       */
      popBack() {
        if (this.size() === 0) {
          return null;
        }
        if (this._backElements.length > 0) {
          const back2 = this._backElements.pop();
          if (this._backOffset >= this._backElements.length) {
            this._backElements = this._backElements.slice(this._backOffset);
            this._backOffset = 0;
          }
          return back2;
        }
        const back = this.back();
        this._frontOffset += 1;
        if (this._frontOffset * 2 < this._frontElements.length) {
          return back;
        }
        this._frontElements = this._frontElements.slice(this._frontOffset);
        this._frontOffset = 0;
        return back;
      }
      /**
       * Returns the front element of the queue
       * @public
       * @returns {number|string|object}
       */
      front() {
        if (this.size() === 0) {
          return null;
        }
        if (this._frontElements.length > 0) {
          return this._frontElements[this._frontElements.length - 1];
        }
        return this._backElements[this._backOffset];
      }
      /**
       * Returns the back element of the queue
       * @public
       * @returns {number|string|object}
       */
      back() {
        if (this.size() === 0) {
          return null;
        }
        if (this._backElements.length > 0) {
          return this._backElements[this._backElements.length - 1];
        }
        return this._frontElements[this._frontOffset];
      }
      /**
       * Returns the number of elements in the deque
       * @public
       * @returns {number}
       */
      size() {
        const frontSize = this._frontElements.length - this._frontOffset;
        const backSize = this._backElements.length - this._backOffset;
        return frontSize + backSize;
      }
      /**
       * Checks if the queue is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }
      /**
       * Returns the remaining elements in the queue as an array
       * @public
       * @returns {array}
       */
      toArray() {
        const backElements = this._backElements.slice(this._backOffset);
        const frontElements = this._frontElements.slice(this._frontElements);
        return frontElements.reverse().concat(backElements);
      }
      /**
       * Clears the queue
       * @public
       */
      clear() {
        this._backElements = [];
        this._frontElements = [];
        this._backOffset = 0;
        this._frontOffset = 0;
      }
      /**
       * Creates a shallow copy of the queue
       * @public
       * @return {Deque}
       */
      clone() {
        return new Deque(this.toArray());
      }
      /**
       * Creates a deque from an existing array
       * @public
       * @static
       * @param {array} elements
       * @return {Deque}
       */
      static fromArray(elements) {
        return new Deque(elements);
      }
    };
    exports.Deque = Deque;
  }
});

// node_modules/@datastructures-js/deque/index.js
var require_deque2 = __commonJS({
  "node_modules/@datastructures-js/deque/index.js"(exports) {
    var { Deque } = require_deque();
    exports.Deque = Deque;
  }
});

// node_modules/@datastructures-js/heap/src/heap.js
var require_heap = __commonJS({
  "node_modules/@datastructures-js/heap/src/heap.js"(exports) {
    var Heap = class {
      /**
       * @param {function} compare
       * @param {array} [_values]
       * @param {number|string|object} [_leaf]
       */
      constructor(compare, _values, _leaf) {
        if (typeof compare !== "function") {
          throw new Error("Heap constructor expects a compare function");
        }
        this._compare = compare;
        this._nodes = Array.isArray(_values) ? _values : [];
        this._leaf = _leaf || null;
      }
      /**
       * Converts the heap to a cloned array without sorting.
       * @public
       * @returns {Array}
       */
      toArray() {
        return Array.from(this._nodes);
      }
      /**
       * Checks if a parent has a left child
       * @private
       */
      _hasLeftChild(parentIndex) {
        const leftChildIndex = parentIndex * 2 + 1;
        return leftChildIndex < this.size();
      }
      /**
       * Checks if a parent has a right child
       * @private
       */
      _hasRightChild(parentIndex) {
        const rightChildIndex = parentIndex * 2 + 2;
        return rightChildIndex < this.size();
      }
      /**
       * Compares two nodes
       * @private
       */
      _compareAt(i, j) {
        return this._compare(this._nodes[i], this._nodes[j]);
      }
      /**
       * Swaps two nodes in the heap
       * @private
       */
      _swap(i, j) {
        const temp = this._nodes[i];
        this._nodes[i] = this._nodes[j];
        this._nodes[j] = temp;
      }
      /**
       * Checks if parent and child should be swapped
       * @private
       */
      _shouldSwap(parentIndex, childIndex) {
        if (parentIndex < 0 || parentIndex >= this.size()) {
          return false;
        }
        if (childIndex < 0 || childIndex >= this.size()) {
          return false;
        }
        return this._compareAt(parentIndex, childIndex) > 0;
      }
      /**
       * Compares children of a parent
       * @private
       */
      _compareChildrenOf(parentIndex) {
        if (!this._hasLeftChild(parentIndex) && !this._hasRightChild(parentIndex)) {
          return -1;
        }
        const leftChildIndex = parentIndex * 2 + 1;
        const rightChildIndex = parentIndex * 2 + 2;
        if (!this._hasLeftChild(parentIndex)) {
          return rightChildIndex;
        }
        if (!this._hasRightChild(parentIndex)) {
          return leftChildIndex;
        }
        const compare = this._compareAt(leftChildIndex, rightChildIndex);
        return compare > 0 ? rightChildIndex : leftChildIndex;
      }
      /**
       * Compares two children before a position
       * @private
       */
      _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {
        const compare = this._compareAt(rightChildIndex, leftChildIndex);
        if (compare <= 0 && rightChildIndex < index) {
          return rightChildIndex;
        }
        return leftChildIndex;
      }
      /**
       * Recursively bubbles up a node if it's in a wrong position
       * @private
       */
      _heapifyUp(startIndex) {
        let childIndex = startIndex;
        let parentIndex = Math.floor((childIndex - 1) / 2);
        while (this._shouldSwap(parentIndex, childIndex)) {
          this._swap(parentIndex, childIndex);
          childIndex = parentIndex;
          parentIndex = Math.floor((childIndex - 1) / 2);
        }
      }
      /**
       * Recursively bubbles down a node if it's in a wrong position
       * @private
       */
      _heapifyDown(startIndex) {
        let parentIndex = startIndex;
        let childIndex = this._compareChildrenOf(parentIndex);
        while (this._shouldSwap(parentIndex, childIndex)) {
          this._swap(parentIndex, childIndex);
          parentIndex = childIndex;
          childIndex = this._compareChildrenOf(parentIndex);
        }
      }
      /**
       * Recursively bubbles down a node before a given index
       * @private
       */
      _heapifyDownUntil(index) {
        let parentIndex = 0;
        let leftChildIndex = 1;
        let rightChildIndex = 2;
        let childIndex;
        while (leftChildIndex < index) {
          childIndex = this._compareChildrenBefore(
            index,
            leftChildIndex,
            rightChildIndex
          );
          if (this._shouldSwap(parentIndex, childIndex)) {
            this._swap(parentIndex, childIndex);
          }
          parentIndex = childIndex;
          leftChildIndex = parentIndex * 2 + 1;
          rightChildIndex = parentIndex * 2 + 2;
        }
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {Heap}
       */
      insert(value) {
        this._nodes.push(value);
        this._heapifyUp(this.size() - 1);
        if (this._leaf === null || this._compare(value, this._leaf) > 0) {
          this._leaf = value;
        }
        return this;
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {Heap}
       */
      push(value) {
        return this.insert(value);
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      extractRoot() {
        if (this.isEmpty()) {
          return null;
        }
        const root = this.root();
        this._nodes[0] = this._nodes[this.size() - 1];
        this._nodes.pop();
        this._heapifyDown(0);
        if (root === this._leaf) {
          this._leaf = this.root();
        }
        return root;
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.extractRoot();
      }
      /**
       * Applies heap sort and return the values sorted by priority
       * @public
       * @returns {array}
       */
      sort() {
        for (let i = this.size() - 1; i > 0; i -= 1) {
          this._swap(0, i);
          this._heapifyDownUntil(i);
        }
        return this._nodes;
      }
      /**
       * Fixes node positions in the heap
       * @public
       * @returns {Heap}
       */
      fix() {
        for (let i = Math.floor(this.size() / 2) - 1; i >= 0; i -= 1) {
          this._heapifyDown(i);
        }
        for (let i = Math.floor(this.size() / 2); i < this.size(); i += 1) {
          const value = this._nodes[i];
          if (this._leaf === null || this._compare(value, this._leaf) > 0) {
            this._leaf = value;
          }
        }
        return this;
      }
      /**
       * Verifies that all heap nodes are in the right position
       * @public
       * @returns {boolean}
       */
      isValid() {
        const isValidRecursive = (parentIndex) => {
          let isValidLeft = true;
          let isValidRight = true;
          if (this._hasLeftChild(parentIndex)) {
            const leftChildIndex = parentIndex * 2 + 1;
            if (this._compareAt(parentIndex, leftChildIndex) > 0) {
              return false;
            }
            isValidLeft = isValidRecursive(leftChildIndex);
          }
          if (this._hasRightChild(parentIndex)) {
            const rightChildIndex = parentIndex * 2 + 2;
            if (this._compareAt(parentIndex, rightChildIndex) > 0) {
              return false;
            }
            isValidRight = isValidRecursive(rightChildIndex);
          }
          return isValidLeft && isValidRight;
        };
        return isValidRecursive(0);
      }
      /**
       * Returns a shallow copy of the heap
       * @public
       * @returns {Heap}
       */
      clone() {
        return new Heap(this._compare, this._nodes.slice(), this._leaf);
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      root() {
        if (this.isEmpty()) {
          return null;
        }
        return this._nodes[0];
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      top() {
        return this.root();
      }
      /**
       * Returns a leaf node in the heap
       * @public
       * @returns {number|string|object}
       */
      leaf() {
        return this._leaf;
      }
      /**
       * Returns the number of nodes in the heap
       * @public
       * @returns {number}
       */
      size() {
        return this._nodes.length;
      }
      /**
       * Checks if the heap is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }
      /**
       * Clears the heap
       * @public
       */
      clear() {
        this._nodes = [];
        this._leaf = null;
      }
      /**
       * Implements an iterable on the heap
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Builds a heap from a array of values
       * @public
       * @static
       * @param {array} values
       * @param {function} compare
       * @returns {Heap}
       */
      static heapify(values, compare) {
        if (!Array.isArray(values)) {
          throw new Error("Heap.heapify expects an array of values");
        }
        if (typeof compare !== "function") {
          throw new Error("Heap.heapify expects a compare function");
        }
        return new Heap(compare, values).fix();
      }
      /**
       * Checks if a list of values is a valid heap
       * @public
       * @static
       * @param {array} values
       * @param {function} compare
       * @returns {boolean}
       */
      static isHeapified(values, compare) {
        return new Heap(compare, values).isValid();
      }
    };
    exports.Heap = Heap;
  }
});

// node_modules/@datastructures-js/heap/src/minHeap.js
var require_minHeap = __commonJS({
  "node_modules/@datastructures-js/heap/src/minHeap.js"(exports) {
    var { Heap } = require_heap();
    var getMinCompare = (getCompareValue) => (a, b) => {
      const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
      const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
      return aVal < bVal ? -1 : 1;
    };
    var MinHeap = class {
      /**
       * @param {function} [getCompareValue]
       * @param {Heap} [_heap]
       */
      constructor(getCompareValue, _heap) {
        this._getCompareValue = getCompareValue;
        this._heap = _heap || new Heap(getMinCompare(getCompareValue));
      }
      /**
       * Converts the heap to a cloned array without sorting.
       * @public
       * @returns {Array}
       */
      toArray() {
        return Array.from(this._heap._nodes);
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {MinHeap}
       */
      insert(value) {
        return this._heap.insert(value);
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {Heap}
       */
      push(value) {
        return this.insert(value);
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      extractRoot() {
        return this._heap.extractRoot();
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.extractRoot();
      }
      /**
       * Applies heap sort and return the values sorted by priority
       * @public
       * @returns {array}
       */
      sort() {
        return this._heap.sort();
      }
      /**
       * Fixes node positions in the heap
       * @public
       * @returns {MinHeap}
       */
      fix() {
        return this._heap.fix();
      }
      /**
       * Verifies that all heap nodes are in the right position
       * @public
       * @returns {boolean}
       */
      isValid() {
        return this._heap.isValid();
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      root() {
        return this._heap.root();
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      top() {
        return this.root();
      }
      /**
       * Returns a leaf node in the heap
       * @public
       * @returns {number|string|object}
       */
      leaf() {
        return this._heap.leaf();
      }
      /**
       * Returns the number of nodes in the heap
       * @public
       * @returns {number}
       */
      size() {
        return this._heap.size();
      }
      /**
       * Checks if the heap is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._heap.isEmpty();
      }
      /**
       * Clears the heap
       * @public
       */
      clear() {
        this._heap.clear();
      }
      /**
       * Returns a shallow copy of the MinHeap
       * @public
       * @returns {MinHeap}
       */
      clone() {
        return new MinHeap(this._getCompareValue, this._heap.clone());
      }
      /**
       * Implements an iterable on the heap
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Builds a MinHeap from an array
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {MinHeap}
       */
      static heapify(values, getCompareValue) {
        if (!Array.isArray(values)) {
          throw new Error("MinHeap.heapify expects an array");
        }
        const heap = new Heap(getMinCompare(getCompareValue), values);
        return new MinHeap(getCompareValue, heap).fix();
      }
      /**
       * Checks if a list of values is a valid min heap
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {boolean}
       */
      static isHeapified(values, getCompareValue) {
        const heap = new Heap(getMinCompare(getCompareValue), values);
        return new MinHeap(getCompareValue, heap).isValid();
      }
    };
    exports.MinHeap = MinHeap;
  }
});

// node_modules/@datastructures-js/heap/src/maxHeap.js
var require_maxHeap = __commonJS({
  "node_modules/@datastructures-js/heap/src/maxHeap.js"(exports) {
    var { Heap } = require_heap();
    var getMaxCompare = (getCompareValue) => (a, b) => {
      const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
      const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
      return aVal < bVal ? 1 : -1;
    };
    var MaxHeap = class {
      /**
       * @param {function} [getCompareValue]
       * @param {Heap} [_heap]
       */
      constructor(getCompareValue, _heap) {
        this._getCompareValue = getCompareValue;
        this._heap = _heap || new Heap(getMaxCompare(getCompareValue));
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {MaxHeap}
       */
      insert(value) {
        return this._heap.insert(value);
      }
      /**
       * Inserts a new value into the heap
       * @public
       * @param {number|string|object} value
       * @returns {Heap}
       */
      push(value) {
        return this.insert(value);
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      extractRoot() {
        return this._heap.extractRoot();
      }
      /**
       * Removes and returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.extractRoot();
      }
      /**
       * Applies heap sort and return the values sorted by priority
       * @public
       * @returns {array}
       */
      sort() {
        return this._heap.sort();
      }
      /**
       * Converts the heap to a cloned array without sorting.
       * @public
       * @returns {Array}
       */
      toArray() {
        return Array.from(this._heap._nodes);
      }
      /**
       * Fixes node positions in the heap
       * @public
       * @returns {MaxHeap}
       */
      fix() {
        return this._heap.fix();
      }
      /**
       * Verifies that all heap nodes are in the right position
       * @public
       * @returns {boolean}
       */
      isValid() {
        return this._heap.isValid();
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      root() {
        return this._heap.root();
      }
      /**
       * Returns the root node in the heap
       * @public
       * @returns {number|string|object}
       */
      top() {
        return this.root();
      }
      /**
       * Returns a leaf node in the heap
       * @public
       * @returns {number|string|object}
       */
      leaf() {
        return this._heap.leaf();
      }
      /**
       * Returns the number of nodes in the heap
       * @public
       * @returns {number}
       */
      size() {
        return this._heap.size();
      }
      /**
       * Checks if the heap is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._heap.isEmpty();
      }
      /**
       * Clears the heap
       * @public
       */
      clear() {
        this._heap.clear();
      }
      /**
       * Returns a shallow copy of the MaxHeap
       * @public
       * @returns {MaxHeap}
       */
      clone() {
        return new MaxHeap(this._getCompareValue, this._heap.clone());
      }
      /**
       * Implements an iterable on the heap
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Builds a MaxHeap from an array
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {MaxHeap}
       */
      static heapify(values, getCompareValue) {
        if (!Array.isArray(values)) {
          throw new Error("MaxHeap.heapify expects an array");
        }
        const heap = new Heap(getMaxCompare(getCompareValue), values);
        return new MaxHeap(getCompareValue, heap).fix();
      }
      /**
       * Checks if a list of values is a valid max heap
       * @public
       * @static
       * @param {array} values
       * @param {function} [getCompareValue]
       * @returns {boolean}
       */
      static isHeapified(values, getCompareValue) {
        const heap = new Heap(getMaxCompare(getCompareValue), values);
        return new MaxHeap(getCompareValue, heap).isValid();
      }
    };
    exports.MaxHeap = MaxHeap;
  }
});

// node_modules/@datastructures-js/heap/index.js
var require_heap2 = __commonJS({
  "node_modules/@datastructures-js/heap/index.js"(exports) {
    var { Heap } = require_heap();
    var { MinHeap } = require_minHeap();
    var { MaxHeap } = require_maxHeap();
    exports.Heap = Heap;
    exports.MinHeap = MinHeap;
    exports.MaxHeap = MaxHeap;
  }
});

// node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js
var require_minPriorityQueue = __commonJS({
  "node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js"(exports) {
    var { Heap, MinHeap } = require_heap2();
    var getMinCompare = (getCompareValue) => (a, b) => {
      const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
      const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
      return aVal < bVal ? -1 : 1;
    };
    var MinPriorityQueue = class {
      constructor(getCompareValue, _heap) {
        if (getCompareValue && typeof getCompareValue !== "function") {
          throw new Error("MinPriorityQueue constructor requires a callback for object values");
        }
        this._heap = _heap || new MinHeap(getCompareValue);
      }
      /**
       * Returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this._heap.root();
      }
      /**
       * Returns an element with lowest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this._heap.leaf();
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MinPriorityQueue}
       */
      enqueue(value) {
        return this._heap.insert(value);
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MinPriorityQueue}
       */
      push(value) {
        return this.enqueue(value);
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        return this._heap.extractRoot();
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }
      /**
       * Removes all elements that match a criteria in the callback
       * @public
       * @param {function} cb
       * @returns {array}
       */
      remove(cb) {
        if (typeof cb !== "function") {
          throw new Error("MinPriorityQueue remove expects a callback");
        }
        const removed = [];
        const dequeued = [];
        while (!this.isEmpty()) {
          const popped = this.pop();
          if (cb(popped)) {
            removed.push(popped);
          } else {
            dequeued.push(popped);
          }
        }
        dequeued.forEach((val) => this.push(val));
        return removed;
      }
      /**
       * Returns the number of elements in the queue
       * @public
       * @returns {number}
       */
      size() {
        return this._heap.size();
      }
      /**
       * Checks if the queue is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._heap.isEmpty();
      }
      /**
       * Clears the queue
       * @public
       */
      clear() {
        this._heap.clear();
      }
      /**
       * Returns a sorted list of elements from highest to lowest priority
       * @public
       * @returns {array}
       */
      toArray() {
        return this._heap.clone().sort().reverse();
      }
      /**
       * Implements an iterable on the min priority queue
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Creates a priority queue from an existing array
       * @public
       * @static
       * @returns {MinPriorityQueue}
       */
      static fromArray(values, getCompareValue) {
        const heap = new Heap(getMinCompare(getCompareValue), values);
        return new MinPriorityQueue(
          getCompareValue,
          new MinHeap(getCompareValue, heap).fix()
        );
      }
    };
    exports.MinPriorityQueue = MinPriorityQueue;
  }
});

// node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js
var require_maxPriorityQueue = __commonJS({
  "node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js"(exports) {
    var { Heap, MaxHeap } = require_heap2();
    var getMaxCompare = (getCompareValue) => (a, b) => {
      const aVal = typeof getCompareValue === "function" ? getCompareValue(a) : a;
      const bVal = typeof getCompareValue === "function" ? getCompareValue(b) : b;
      return aVal < bVal ? 1 : -1;
    };
    var MaxPriorityQueue = class {
      constructor(getCompareValue, _heap) {
        if (getCompareValue && typeof getCompareValue !== "function") {
          throw new Error("MaxPriorityQueue constructor requires a callback for object values");
        }
        this._heap = _heap || new MaxHeap(getCompareValue);
      }
      /**
       * Returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this._heap.root();
      }
      /**
       * Returns an element with lowest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this._heap.leaf();
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MaxPriorityQueue}
       */
      enqueue(value) {
        return this._heap.insert(value);
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {MaxPriorityQueue}
       */
      push(value) {
        return this.enqueue(value);
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        return this._heap.extractRoot();
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }
      /**
       * Removes all elements that match a criteria in the callback
       * @public
       * @param {function} cb
       * @returns {array}
       */
      remove(cb) {
        if (typeof cb !== "function") {
          throw new Error("MaxPriorityQueue remove expects a callback");
        }
        const removed = [];
        const dequeued = [];
        while (!this.isEmpty()) {
          const popped = this.pop();
          if (cb(popped)) {
            removed.push(popped);
          } else {
            dequeued.push(popped);
          }
        }
        dequeued.forEach((val) => this.push(val));
        return removed;
      }
      /**
       * Returns the number of elements in the queue
       * @public
       * @returns {number}
       */
      size() {
        return this._heap.size();
      }
      /**
       * Checks if the queue is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._heap.isEmpty();
      }
      /**
       * Clears the queue
       * @public
       */
      clear() {
        this._heap.clear();
      }
      /**
       * Returns a sorted list of elements from highest to lowest priority
       * @public
       * @returns {array}
       */
      toArray() {
        return this._heap.clone().sort().reverse();
      }
      /**
       * Implements an iterable on the min priority queue
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Creates a priority queue from an existing array
       * @public
       * @static
       * @returns {MaxPriorityQueue}
       */
      static fromArray(values, getCompareValue) {
        const heap = new Heap(getMaxCompare(getCompareValue), values);
        return new MaxPriorityQueue(
          getCompareValue,
          new MaxHeap(getCompareValue, heap).fix()
        );
      }
    };
    exports.MaxPriorityQueue = MaxPriorityQueue;
  }
});

// node_modules/@datastructures-js/priority-queue/src/priorityQueue.js
var require_priorityQueue = __commonJS({
  "node_modules/@datastructures-js/priority-queue/src/priorityQueue.js"(exports) {
    var { Heap } = require_heap2();
    var PriorityQueue = class {
      /**
       * Creates a priority queue
       * @params {function} compare
       */
      constructor(compare, _values) {
        if (typeof compare !== "function") {
          throw new Error("PriorityQueue constructor expects a compare function");
        }
        this._heap = new Heap(compare, _values);
        if (_values) {
          this._heap.fix();
        }
      }
      /**
       * Returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this._heap.root();
      }
      /**
       * Returns an element with lowest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this._heap.leaf();
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {PriorityQueue}
       */
      enqueue(value) {
        return this._heap.insert(value);
      }
      /**
       * Adds a value to the queue
       * @public
       * @param {number|string|object} value
       * @returns {PriorityQueue}
       */
      push(value) {
        return this.enqueue(value);
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        return this._heap.extractRoot();
      }
      /**
       * Removes and returns an element with highest priority in the queue
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }
      /**
       * Removes all elements that match a criteria in the callback
       * @public
       * @param {function} cb
       * @returns {array}
       */
      remove(cb) {
        if (typeof cb !== "function") {
          throw new Error("PriorityQueue remove expects a callback");
        }
        const removed = [];
        const dequeued = [];
        while (!this.isEmpty()) {
          const popped = this.pop();
          if (cb(popped)) {
            removed.push(popped);
          } else {
            dequeued.push(popped);
          }
        }
        dequeued.forEach((val) => this.push(val));
        return removed;
      }
      /**
       * Returns the number of elements in the queue
       * @public
       * @returns {number}
       */
      size() {
        return this._heap.size();
      }
      /**
       * Checks if the queue is empty
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._heap.isEmpty();
      }
      /**
       * Clears the queue
       * @public
       */
      clear() {
        this._heap.clear();
      }
      /**
       * Returns a sorted list of elements from highest to lowest priority
       * @public
       * @returns {array}
       */
      toArray() {
        return this._heap.clone().sort().reverse();
      }
      /**
       * Implements an iterable on the priority queue
       * @public
       */
      [Symbol.iterator]() {
        let size = this.size();
        return {
          next: () => {
            size -= 1;
            return {
              value: this.pop(),
              done: size === -1
            };
          }
        };
      }
      /**
       * Creates a priority queue from an existing array
       * @public
       * @static
       * @returns {PriorityQueue}
       */
      static fromArray(values, compare) {
        return new PriorityQueue(compare, values);
      }
    };
    exports.PriorityQueue = PriorityQueue;
  }
});

// node_modules/@datastructures-js/priority-queue/index.js
var require_priority_queue = __commonJS({
  "node_modules/@datastructures-js/priority-queue/index.js"(exports, module) {
    var { MinPriorityQueue } = require_minPriorityQueue();
    var { MaxPriorityQueue } = require_maxPriorityQueue();
    var { PriorityQueue } = require_priorityQueue();
    module.exports = { MinPriorityQueue, MaxPriorityQueue, PriorityQueue };
  }
});

// node_modules/@datastructures-js/set/src/enhancedSet.js
var require_enhancedSet = __commonJS({
  "node_modules/@datastructures-js/set/src/enhancedSet.js"(exports) {
    var EnhancedSet = class extends Set {
      /**
       * Returns a set of all elements of the set and another set
       * @public
       * @param {Set} set
       * @returns {EnhancedSet}
       */
      union(set) {
        if (!(set instanceof Set)) {
          throw new Error(".union expects a Set");
        }
        const result = new EnhancedSet();
        this.forEach((element) => result.add(element));
        set.forEach((element) => result.add(element));
        return result;
      }
      /**
       * Returns the common elements between the set and another set
       * @public
       * @param {Set} set
       * @returns {EnhancedSet}
       */
      intersect(set) {
        if (!(set instanceof Set)) {
          throw new Error(".intersect expects a Set");
        }
        const result = new EnhancedSet();
        this.forEach((element) => {
          if (set.has(element)) {
            result.add(element);
          }
        });
        return result;
      }
      /**
       * Returns the elements in the set that are not in another set
       * @public
       * @param {Set} set
       * @returns {EnhancedSet}
       */
      complement(set) {
        if (!(set instanceof Set)) {
          throw new Error(".complement expects a Set");
        }
        const result = new EnhancedSet();
        this.forEach((element) => {
          if (!set.has(element)) {
            result.add(element);
          }
        });
        return result;
      }
      /**
       * Returns the elements in the set that are not in another set
       * @public
       * @param {Set} set
       * @returns {EnhancedSet}
       */
      diff(set) {
        return this.complement(set);
      }
      /**
       * Checks if the set is a subset of another set
       * @public
       * @param {Set} set
       * @returns {boolean}
       */
      isSubsetOf(set) {
        if (!(set instanceof Set))
          return false;
        let count = 0;
        this.forEach((element) => {
          if (set.has(element)) {
            count += 1;
          }
        });
        return count === this.size;
      }
      /**
       * Checks if the set is a superset of another set
       * @public
       * @param {Set} set
       * @returns {boolean}
       */
      isSupersetOf(set) {
        if (!(set instanceof Set))
          return false;
        let count = 0;
        set.forEach((element) => {
          if (this.has(element)) {
            count += 1;
          }
        });
        return count === set.size;
      }
      /**
       * Applies a cartesian product with another set
       * @public
       * @param {Set} set
       * @param {string} [separator]
       * @returns {EnhancedSet}
       */
      product(set, seprator = "") {
        if (!(set instanceof Set)) {
          throw new Error(".product expects a Set");
        }
        const result = new EnhancedSet();
        this.forEach((e1) => {
          set.forEach((e2) => {
            result.add(`${e1}${seprator}${e2}`);
          });
        });
        return result;
      }
      /**
       * Applies cartesian product with the set itself
       * @public
       * @param {number} m
       * @param {string} [separator]
       * @returns {EnhancedSet}
       */
      power(m, seprator = "") {
        if (Number.isNaN(+m) || +m < 0) {
          throw new Error(".power expects a positive number");
        }
        if (+m === 0)
          return new EnhancedSet();
        let result = this.clone();
        for (let i = 0; i < +m - 1; i += 1) {
          result = result.product(this, seprator);
        }
        return result;
      }
      /**
       * Finds m permutations of the set
       * @public
       * @param {number} m
       * @param {string} [separator]
       * @returns {EnhancedSet}
       */
      permutations(m, separator = "") {
        if (Number.isNaN(+m) || +m < 0) {
          throw new Error(".permutations expects a positive number");
        }
        if (m > this.size) {
          throw new Error(".permutations expects a number less or euqal set size");
        }
        const result = new EnhancedSet();
        const generatePermutation = (currentSet, i = 0, prefix = "") => {
          if (i === m && prefix.length > 0) {
            result.add(prefix);
            return;
          }
          currentSet.forEach((el) => {
            const nextSet = currentSet.clone();
            nextSet.delete(el);
            const acc = prefix.length ? `${prefix}${separator}${el}` : `${el}`;
            generatePermutation(nextSet, i + 1, acc);
          });
        };
        generatePermutation(this.clone());
        return result;
      }
      /**
       * Checks if two sets are equal
       * @public
       * @param {Set} set
       * @returns {boolean}
       */
      equals(set) {
        if (!(set instanceof Set)) {
          throw new Error(".equals expects a Set");
        }
        return this.isSubsetOf(set) && this.size === set.size;
      }
      /**
       * Filters the set elements using a callback
       * @public
       * @param {function} cb
       * @returns {EnhancedSet}
       */
      filter(cb) {
        if (typeof cb !== "function") {
          throw new Error(".filter expects a callback");
        }
        const result = new EnhancedSet();
        this.forEach((element) => {
          if (cb(element)) {
            result.add(element);
          }
        });
        return result;
      }
      /**
       * Converst the set into an array
       * @public
       * @returns {array}
       */
      toArray() {
        return Array.from(this);
      }
      /**
       * Clones the set
       * @public
       * @returns {EnhancedSet}
       */
      clone() {
        return new EnhancedSet(this.toArray());
      }
    };
    exports.EnhancedSet = EnhancedSet;
  }
});

// node_modules/@datastructures-js/set/index.js
var require_set = __commonJS({
  "node_modules/@datastructures-js/set/index.js"(exports) {
    var { EnhancedSet } = require_enhancedSet();
    exports.EnhancedSet = EnhancedSet;
  }
});

// node_modules/@datastructures-js/linked-list/src/linkedListNode.js
var require_linkedListNode = __commonJS({
  "node_modules/@datastructures-js/linked-list/src/linkedListNode.js"(exports) {
    var LinkedListNode = class {
      /**
       * Creates a linked list node.
       * @param {any} value
       * @param {LinkedListNode} [next]
       */
      constructor(value, next) {
        this._value = value;
        this.setNext(next);
      }
      /**
       * @public
       * @param {any} value
       * @returns {LinkedListNode}
       */
      setValue(value) {
        this._value = value;
        return this;
      }
      /**
       * @public
       * @returns {any}
       */
      getValue() {
        return this._value;
      }
      /**
       * @public
       * @param {LinkedListNode} [next]
       * @returns {LinkedListNode}
       */
      setNext(next) {
        if (next && !(next instanceof LinkedListNode)) {
          throw new Error("setNext expects a LinkedListNode or null");
        }
        this._next = next || null;
        return this;
      }
      /**
       * @public
       * @returns {LinkedListNode}
       */
      getNext() {
        return this._next;
      }
      /**
       * @public
       * @returns {boolean}
       */
      hasNext() {
        return this._next instanceof LinkedListNode;
      }
    };
    exports.LinkedListNode = LinkedListNode;
  }
});

// node_modules/@datastructures-js/linked-list/src/linkedList.js
var require_linkedList = __commonJS({
  "node_modules/@datastructures-js/linked-list/src/linkedList.js"(exports) {
    var { LinkedListNode } = require_linkedListNode();
    var LinkedList = class {
      constructor() {
        this._head = null;
        this._count = 0;
      }
      /**
       * Adds a node at the beginning of the list.
       * @public
       * @param {any} value
       * @returns {LinkedListNode}
       */
      insertFirst(value) {
        this._head = new LinkedListNode(value, this._head);
        this._count += 1;
        return this._head;
      }
      /**
       * Adds a node at the end of the list.
       * @public
       * @param {any} value
       * @param {LinkedListNode} [startingNode]
       * @returns {LinkedListNode}
       */
      insertLast(value, startingNode) {
        if (this.isEmpty()) {
          return this.insertFirst(value);
        }
        if (startingNode && !(startingNode instanceof LinkedListNode)) {
          throw new Error("insertLast expects a LinkedListNode starting node");
        }
        let current = startingNode || this._head;
        while (current.hasNext()) {
          current = current.getNext();
        }
        current.setNext(new LinkedListNode(value, null));
        this._count += 1;
        return current.getNext();
      }
      /**
       * Adds a node at a specific position.
       * @public
       * @param {number} position
       * @param {any} value
       * @returns {LinkedListNode}
       */
      insertAt(position, value) {
        if (Number.isNaN(+position) || position < 0 || position > this._count) {
          throw new Error(".insertAt expects a position num <= linked list size");
        }
        if (position === 0) {
          return this.insertFirst(value);
        }
        let currentPosition = 1;
        let prev = this._head;
        while (currentPosition < position) {
          currentPosition += 1;
          prev = prev.getNext();
        }
        prev.setNext(new LinkedListNode(value, prev.getNext()));
        this._count += 1;
        return prev.getNext();
      }
      /**
       * Removes the head node.
       * @public
       * @returns {LinkedListNode}
       */
      removeFirst() {
        if (this.isEmpty())
          return null;
        const removed = this._head;
        this._head = this._head.getNext();
        this._count -= 1;
        return removed.setNext(null);
      }
      /**
       * Removes the last node in the list.
       * @public
       * @returns {LinkedListNode}
       */
      removeLast() {
        if (this.isEmpty())
          return null;
        let prev = null;
        let current = this._head;
        while (current.hasNext()) {
          prev = current;
          current = current.getNext();
        }
        if (prev === null) {
          return this.removeFirst();
        }
        prev.setNext(null);
        this._count -= 1;
        return current;
      }
      /**
       * Removes all nodes based on a callback.
       * @public
       * @param {function} cb
       * @returns {number} number of removed nodes
       */
      removeEach(cb) {
        if (typeof cb !== "function") {
          throw new Error(".removeEach(cb) expects a callback");
        }
        let removedCount = 0;
        let position = 0;
        let prev = null;
        let current = this._head;
        while (current instanceof LinkedListNode) {
          if (cb(current, position)) {
            if (prev === null) {
              this._head = this._head.getNext();
              current = this._head;
            } else {
              prev.setNext(prev.getNext().getNext());
              current = current.getNext();
            }
            this._count -= 1;
            removedCount += 1;
          } else {
            prev = current;
            current = current.getNext();
          }
          position += 1;
        }
        return removedCount;
      }
      /**
       * Removes a node at a specific position.
       * @public
       * @param {number} position
       * @returns {LinkedListNode}
       */
      removeAt(position) {
        if (Number.isNaN(+position) || position < 0 || position >= this._count) {
          return null;
        }
        if (position === 0) {
          return this.removeFirst();
        }
        let counter = 1;
        let prev = this._head;
        while (counter < position) {
          counter += 1;
          prev = prev.getNext();
        }
        const removed = prev.getNext();
        prev.setNext(prev.getNext().getNext());
        this._count -= 1;
        return removed.setNext(null);
      }
      /**
       * Traverses the list from beginning to end.
       * @public
       * @param {function} cb
       */
      forEach(cb) {
        if (typeof cb !== "function") {
          throw new Error(".forEach(cb) expects a callback");
        }
        let current = this._head;
        let position = 0;
        while (current instanceof LinkedListNode) {
          cb(current, position);
          position += 1;
          current = current.getNext();
        }
      }
      /**
       * Finds one node in the list based on a callback.
       * @public
       * @param {function} cb
       * @param {DoublyLinkedListNode} [startingNode]
       * @returns {LinkedListNode}
       */
      find(cb, startingNode = this._head) {
        if (typeof cb !== "function") {
          throw new Error(".find(cb) expects a callback");
        }
        if (startingNode && !(startingNode instanceof LinkedListNode)) {
          throw new Error(".find(cb) expects to start from a LinkedListNode");
        }
        let current = startingNode;
        while (current instanceof LinkedListNode) {
          if (cb(current)) {
            return current;
          }
          current = current.getNext();
        }
        return null;
      }
      /**
       * Filters the list based on a callback.
       * @public
       * @param {function} cb - callback should return true for required nodes.
       * @returns {LinkedList}
       */
      filter(cb) {
        if (typeof cb !== "function") {
          throw new Error(".filter(cb) expects a callback");
        }
        let last = null;
        const result = new LinkedList();
        this.forEach((node, position) => {
          if (!cb(node, position))
            return;
          last = result.insertLast(node.getValue(), last);
        });
        return result;
      }
      /**
       * Returns the head node.
       * @public
       * @returns {LinkedListNode}
       */
      head() {
        return this._head;
      }
      /**
       * Returns the nodes count in the list.
       * @public
       * @returns {number}
       */
      count() {
        return this._count;
      }
      /**
       * Converts the linked list into an array.
       * @public
       * @returns {array}
       */
      toArray() {
        const result = [];
        this.forEach((node) => result.push(node.getValue()));
        return result;
      }
      /**
       * Checks if the list is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._head === null;
      }
      /**
       * Clears the list
       * @public
       */
      clear() {
        this._head = null;
        this._count = 0;
      }
      /**
       * Creates a linked list from an array
       * @public
       * @static
       * @param {array} values
       * @return {LinkedList}
       */
      static fromArray(values) {
        if (!Array.isArray(values)) {
          throw new Error("cannot create LinkedList from none-array values");
        }
        const linkedList = new LinkedList();
        let lastInserted = null;
        values.forEach((value) => {
          lastInserted = linkedList.insertLast(value, lastInserted);
        });
        return linkedList;
      }
    };
    exports.LinkedList = LinkedList;
  }
});

// node_modules/@datastructures-js/linked-list/src/doublyLinkedListNode.js
var require_doublyLinkedListNode = __commonJS({
  "node_modules/@datastructures-js/linked-list/src/doublyLinkedListNode.js"(exports) {
    var DoublyLinkedListNode = class {
      /**
       * Creates a doubly linked list node.
       * @param {any} value
       * @param {DoublyLinkedListNode} [prev]
       * @param {DoublyLinkedListNode} [next]
       */
      constructor(value, prev, next) {
        this._value = value;
        this.setPrev(prev);
        this.setNext(next);
      }
      /**
       * @public
       * @param {object} value
       */
      setValue(value) {
        this._value = value;
        return this;
      }
      /**
       * @public
       * @returns {object}
       */
      getValue() {
        return this._value;
      }
      /**
       * @public
       * @param {DoublyLinkedListNode} [next]
       * @returns {DoublyLinkedListNode}
       */
      setNext(next) {
        if (next && !(next instanceof DoublyLinkedListNode)) {
          throw new Error("setNext expects a DoublyLinkedListNode or null");
        }
        this._next = next || null;
        return this;
      }
      /**
       * @public
       * @returns {DoublyLinkedListNode}
       */
      getNext() {
        return this._next;
      }
      /**
       * @public
       * @returns {boolean}
       */
      hasNext() {
        return this._next instanceof DoublyLinkedListNode;
      }
      /**
       * @public
       * @param {DoublyLinkedListNode} [prev]
       * @returns {DoublyLinkedList}
       */
      setPrev(prev) {
        if (prev && !(prev instanceof DoublyLinkedListNode)) {
          throw new Error("setPrev expects a DoublyLinkedListNode or null");
        }
        this._prev = prev || null;
        return this;
      }
      /**
       * @public
       * @returns {DoublyLinkedListNode}
       */
      getPrev() {
        return this._prev;
      }
      /**
       * @public
       * @returns {boolean}
       */
      hasPrev() {
        return this._prev instanceof DoublyLinkedListNode;
      }
    };
    exports.DoublyLinkedListNode = DoublyLinkedListNode;
  }
});

// node_modules/@datastructures-js/linked-list/src/doublyLinkedList.js
var require_doublyLinkedList = __commonJS({
  "node_modules/@datastructures-js/linked-list/src/doublyLinkedList.js"(exports) {
    var { DoublyLinkedListNode } = require_doublyLinkedListNode();
    var DoublyLinkedList = class {
      constructor() {
        this._head = null;
        this._tail = null;
        this._count = 0;
      }
      /**
       * Adds a node at the beginning of the list.
       * @public
       * @param {any} value
       * @returns {DoublyLinkedListNode}
       */
      insertFirst(value) {
        const newNode = new DoublyLinkedListNode(value);
        if (this.isEmpty()) {
          this._head = newNode;
          this._tail = newNode;
        } else {
          this._head.setPrev(newNode);
          newNode.setNext(this._head);
          this._head = newNode;
        }
        this._count += 1;
        return newNode;
      }
      /**
       * Adds a node at the end of the list.
       * @public
       * @param {any} value
       * @returns {DoublyLinkedListNode}
       */
      insertLast(value) {
        const newNode = new DoublyLinkedListNode(value);
        if (this.isEmpty()) {
          this._head = newNode;
          this._tail = newNode;
        } else {
          newNode.setPrev(this._tail);
          this._tail.setNext(newNode);
          this._tail = newNode;
        }
        this._count += 1;
        return newNode;
      }
      /**
       * Adds a node at a specific position.
       * @public
       * @param {number} position
       * @param {any} value
       * @returns {DoublyLinkedListNode}
       */
      insertAt(position, value) {
        if (Number.isNaN(+position) || position < 0 || position > this._count) {
          throw new Error(".insertAt expects a position num <= linked list size");
        }
        if (position === 0) {
          return this.insertFirst(value);
        }
        if (position === this._count) {
          return this.insertLast(value);
        }
        let currentPosition = 1;
        let prev = this._head;
        while (currentPosition < position) {
          currentPosition += 1;
          prev = prev.getNext();
        }
        const newNode = new DoublyLinkedListNode(value);
        newNode.setNext(prev.getNext());
        newNode.setPrev(prev);
        newNode.getNext().setPrev(newNode);
        newNode.getPrev().setNext(newNode);
        this._count += 1;
        return newNode;
      }
      /**
       * Removes the head node.
       * @public
       * @returns {DoublyLinkedListNode}
       */
      removeFirst() {
        if (this.isEmpty())
          return null;
        const removedNode = this._head;
        if (this._head.hasNext()) {
          this._head = this._head.getNext();
          this._head.setPrev(null);
        } else {
          this._head = null;
          this._tail = null;
        }
        this._count -= 1;
        return removedNode.setNext(null);
      }
      /**
       * Removes the tail node.
       * @public
       * @returns {DoublyLinkedListNode}
       */
      removeLast() {
        if (this.isEmpty())
          return null;
        const removedNode = this._tail;
        if (this._tail.hasPrev()) {
          this._tail = this._tail.getPrev();
          this._tail.setNext(null);
        } else {
          this._head = null;
          this._tail = null;
        }
        this._count -= 1;
        return removedNode.setPrev(null);
      }
      /**
       * Removes a node in a specific position.
       * @public
       * @param {number} position
       * @returns {DoublyLinkedListNode}
       */
      removeAt(position) {
        if (Number.isNaN(+position) || position < 0 || position >= this._count) {
          return null;
        }
        if (position === 0) {
          return this.removeFirst();
        }
        if (position === this._count - 1) {
          return this.removeLast();
        }
        let currentPosition = 1;
        let current = this._head.getNext();
        while (currentPosition < position) {
          currentPosition += 1;
          current = current.getNext();
        }
        return this.remove(current);
      }
      /**
       * Removes a node from the list by its reference.
       * @public
       * @param {DoublyLinkedListNode} node
       * @returns {DoublyLinkedListNode}
       */
      remove(node) {
        if (node && !(node instanceof DoublyLinkedListNode)) {
          throw new Error("remove: expects a DoublyLinkedListNode node");
        }
        if (!node) {
          return null;
        }
        if (!node.hasPrev()) {
          return this.removeFirst();
        }
        if (!node.hasNext()) {
          return this.removeLast();
        }
        node.getPrev().setNext(node.getNext());
        node.getNext().setPrev(node.getPrev());
        this._count -= 1;
        return node.setPrev(null).setNext(null);
      }
      /**
       * Removes all nodes based on a callback.
       * @public
       * @param {function} cb
       * @returns {number} number of removed nodes
       */
      removeEach(cb) {
        if (typeof cb !== "function") {
          throw new Error(".removeEach(cb) expects a callback");
        }
        let removedCount = 0;
        let position = 0;
        let current = this._head;
        while (current instanceof DoublyLinkedListNode) {
          if (cb(current, position)) {
            const next = current.getNext();
            this.remove(current);
            removedCount += 1;
            current = next;
          } else {
            current = current.getNext();
          }
          position += 1;
        }
        return removedCount;
      }
      /**
       * Traverses the list from beginning to end.
       * @public
       * @param {function} cb
       */
      forEach(cb) {
        if (typeof cb !== "function") {
          throw new Error(".forEach(cb) expects a callback");
        }
        let current = this._head;
        let position = 0;
        while (current instanceof DoublyLinkedListNode) {
          cb(current, position);
          position += 1;
          current = current.getNext();
        }
      }
      /**
       * Traverses the list backward from end to beginning
       * @public
       * @param {function} cb
       */
      forEachReverse(cb) {
        if (typeof cb !== "function") {
          throw new Error(".forEachReverse(cb) expects a callback");
        }
        let current = this._tail;
        let position = this._count - 1;
        while (current instanceof DoublyLinkedListNode) {
          cb(current, position);
          position -= 1;
          current = current.getPrev();
        }
      }
      /**
       * Finds a node in the list using a callback
       * @public
       * @param {function} cb
       * @param {DoublyLinkedListNode} [startingNode]
       * @returns {DoublyLinkedListNode}
       */
      find(cb, startingNode = this._head) {
        if (typeof cb !== "function") {
          throw new Error(".find(cb) expects a callback");
        }
        if (startingNode && !(startingNode instanceof DoublyLinkedListNode)) {
          throw new Error(".find(cb) expects to start from a DoublyLinkedListNode");
        }
        let current = startingNode;
        while (current instanceof DoublyLinkedListNode) {
          if (cb(current)) {
            return current;
          }
          current = current.getNext();
        }
        return null;
      }
      /**
       * Finds a node in the list using a callback in reverse order
       * @public
       * @param {function} cb
       * @param {DoublyLinkedListNode} [startingNode]
       * @returns {DoublyLinkedListNode}
       */
      findReverse(cb, startingNode = this._tail) {
        if (typeof cb !== "function") {
          throw new Error(".findReverse(cb) expects a callback");
        }
        if (startingNode && !(startingNode instanceof DoublyLinkedListNode)) {
          throw new Error(".findReverse(cb) expects to start from a DoublyLinkedListNode");
        }
        let current = startingNode;
        while (current instanceof DoublyLinkedListNode) {
          if (cb(current)) {
            return current;
          }
          current = current.getPrev();
        }
        return null;
      }
      /**
       * Filters the list based on a callback.
       * @public
       * @param {function} cb
       * @returns {LinkedList}
       */
      filter(cb) {
        if (typeof cb !== "function") {
          throw new Error(".filter(cb) expects a callback");
        }
        const result = new DoublyLinkedList();
        this.forEach((node, position) => {
          if (!cb(node, position))
            return;
          result.insertLast(node.getValue());
        });
        return result;
      }
      /**
       * Returns the head node.
       * @public
       * @returns {DoublyLinkedListNode}
       */
      head() {
        return this._head;
      }
      /**
       * Returns the tail node.
       * @public
       * @returns {DoublyLinkedListNode}
       */
      tail() {
        return this._tail;
      }
      /**
       * Returns the nodes count in the list.
       * @public
       * @returns {number}
       */
      count() {
        return this._count;
      }
      /**
       * Converts the doubly linked list into an array.
       * @public
       * @returns {array}
       */
      toArray() {
        const result = [];
        this.forEach((node) => result.push(node.getValue()));
        return result;
      }
      /**
       * Checks if the list is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this._head === null;
      }
      /**
       * Clears the list
       * @public
       */
      clear() {
        this._head = null;
        this._tail = null;
        this._count = 0;
      }
      /**
       * Creates a doubly linked list from an array
       * @public
       * @static
       * @param {array} values
       * @return {DoublyLinkedList}
       */
      static fromArray(values) {
        if (!Array.isArray(values)) {
          throw new Error("cannot create DoublyLinkedList from none-array values");
        }
        const doublyLinkedList = new DoublyLinkedList();
        values.forEach((value) => {
          doublyLinkedList.insertLast(value);
        });
        return doublyLinkedList;
      }
    };
    exports.DoublyLinkedList = DoublyLinkedList;
  }
});

// node_modules/@datastructures-js/linked-list/index.js
var require_linked_list = __commonJS({
  "node_modules/@datastructures-js/linked-list/index.js"(exports, module) {
    var { LinkedListNode } = require_linkedListNode();
    var { LinkedList } = require_linkedList();
    var { DoublyLinkedListNode } = require_doublyLinkedListNode();
    var { DoublyLinkedList } = require_doublyLinkedList();
    module.exports = {
      LinkedListNode,
      LinkedList,
      DoublyLinkedListNode,
      DoublyLinkedList
    };
  }
});

// node_modules/@datastructures-js/trie/src/trieNode.js
var require_trieNode = __commonJS({
  "node_modules/@datastructures-js/trie/src/trieNode.js"(exports) {
    var TrieNode = class {
      constructor(char) {
        this._char = char;
        this._isEndOfWord = false;
        this._parent = null;
        this._children = /* @__PURE__ */ new Map();
      }
      /**
       * @public
       * @return {boolean}
       */
      isRoot() {
        return this._char === "";
      }
      /**
       * @public
       * @return {boolean}
       */
      isLeaf() {
        return this._children.size === 0;
      }
      /**
       * @public
       * @returns {string}
       */
      getChar() {
        return this._char;
      }
      /**
       * @internal
       * @param {TrieNode} parentNode
       */
      setParent(parentNode) {
        this._parent = parentNode;
        return this;
      }
      /**
       * @public
       * @return {TrieNode}
       */
      getParent() {
        return this._parent;
      }
      /**
       * @internal
       * @param {boolean} isEndOfWord
       */
      setEndOfWord(isEndOfWord) {
        this._isEndOfWord = isEndOfWord;
        return this;
      }
      /**
       * @public
       * @return {boolean}
       */
      isEndOfWord() {
        return this._isEndOfWord;
      }
      /**
       * @internal
       * @param {string} char
       */
      addChild(char) {
        const childNode = new TrieNode(char);
        childNode.setParent(this);
        this._children.set(char, childNode);
        return this;
      }
      /**
       * @internal
       * @param {string} char
       * @return {boolean}
       */
      removeChild(char) {
        return this._children.delete(char);
      }
      /**
       * @public
       * @param {string} char
       * @return {TrieNode}
       */
      getChild(char) {
        return this._children.get(char) || null;
      }
      /**
       * @public
       * @param {string} char
       * @return {boolean}
       */
      hasChild(char) {
        return this._children.has(char);
      }
      /**
       * @internal
       * @return {Map}
       */
      children() {
        return this._children;
      }
      /**
       * @public
       * @return {number}
       */
      childrenCount() {
        return this._children.size;
      }
    };
    exports.TrieNode = TrieNode;
  }
});

// node_modules/@datastructures-js/trie/src/trie.js
var require_trie = __commonJS({
  "node_modules/@datastructures-js/trie/src/trie.js"(exports) {
    var { TrieNode } = require_trieNode();
    var Trie = class {
      constructor() {
        this._root = new TrieNode("");
        this._wordsCount = 0;
        this._nodesCount = 1;
      }
      /**
       * Inserts a word into the trie
       * @public
       * @param {any} value
       * @returns {Trie}
       */
      insert(value) {
        if (value === void 0 || value === null) {
          return this;
        }
        const word = value.toString();
        let currentNode = this._root;
        for (let i = 0; i < word.length; i += 1) {
          if (!currentNode.hasChild(word[i])) {
            currentNode.addChild(word[i]);
            this._nodesCount += 1;
          }
          currentNode = currentNode.getChild(word[i]);
        }
        if (!currentNode.isEndOfWord()) {
          currentNode.setEndOfWord(true);
          this._wordsCount += 1;
        }
        return this;
      }
      /**
       * Checks if a word exists in the trie
       * @public
       * @param {any} value
       * @returns {boolean}
       */
      has(value) {
        if (value === void 0 || value === null) {
          return false;
        }
        const word = value.toString();
        let currentNode = this._root;
        for (let i = 0; i < word.length; i += 1) {
          if (!currentNode.hasChild(word[i])) {
            return false;
          }
          currentNode = currentNode.getChild(word[i]);
        }
        if (!currentNode.isEndOfWord()) {
          return false;
        }
        return true;
      }
      /**
       * Finds a word in the trie and returns its last char node
       * @public
       * @param {any} value
       * @returns {TrieNode}
       */
      find(value) {
        if (value === void 0 || value === null) {
          return null;
        }
        const word = value.toString();
        let currentNode = this._root;
        for (let i = 0; i < word.length; i += 1) {
          if (!currentNode.hasChild(word[i])) {
            return null;
          }
          currentNode = currentNode.getChild(word[i]);
        }
        if (!currentNode.isEndOfWord()) {
          return null;
        }
        return currentNode;
      }
      /**
       * Removes a word from the trie
       * @public
       * @param {string} word
       * @returns {string | null}
       */
      remove(value) {
        if (value === void 0 || value === null) {
          return null;
        }
        const word = value.toString();
        let currentNode = this._root;
        for (let i = 0; i < word.length; i += 1) {
          if (!currentNode.hasChild(word[i])) {
            return null;
          }
          currentNode = currentNode.getChild(word[i]);
        }
        if (!currentNode.isEndOfWord()) {
          return null;
        }
        if (currentNode.childrenCount() > 0 || word === "") {
          currentNode.setEndOfWord(false);
          this._wordsCount -= 1;
          return word;
        }
        do {
          currentNode.getParent().removeChild(currentNode.getChar());
          this._nodesCount -= 1;
          currentNode = currentNode.getParent();
        } while (currentNode.isLeaf() && !currentNode.isEndOfWord() && !currentNode.isRoot());
        this._wordsCount -= 1;
        return word;
      }
      /**
       * Traverse the trie and pass words to a callback
       * @public
       * @param {function} cb
       */
      forEach(cb) {
        if (typeof cb !== "function") {
          throw new Error("Trie.forEach expects a callback function");
        }
        const forEachRecursive = (node = this._root, word = "") => {
          if (node.isEndOfWord()) {
            cb(word);
          }
          node.children().forEach((child) => {
            forEachRecursive(child, word + child.getChar());
          });
        };
        return forEachRecursive();
      }
      /**
       * Converts the trie into an array of words
       * @public
       * @returns {array}
       */
      toArray() {
        const result = [];
        this.forEach((word) => result.push(word));
        return result;
      }
      /**
       * @public
       * @returns {number}
       */
      nodesCount() {
        return this._nodesCount;
      }
      /**
       * @public
       * @returns {number}
       */
      wordsCount() {
        return this._wordsCount;
      }
      /**
       * Clears the trie
       * @public
       */
      clear() {
        this._root = new TrieNode("");
        this._nodesCount = 1;
        this._wordsCount = 0;
      }
      /**
       * Converts an existing list into a trie
       * @public
       * @static
       * @returns {Trie}
       */
      static fromArray(values) {
        const trie = new Trie();
        values.forEach((value) => trie.insert(value));
        return trie;
      }
    };
    exports.Trie = Trie;
  }
});

// node_modules/@datastructures-js/trie/index.js
var require_trie2 = __commonJS({
  "node_modules/@datastructures-js/trie/index.js"(exports) {
    var { Trie } = require_trie();
    var { TrieNode } = require_trieNode();
    exports.TrieNode = TrieNode;
    exports.Trie = Trie;
  }
});

// node_modules/@datastructures-js/graph/node_modules/@datastructures-js/queue/src/queue.js
var require_queue3 = __commonJS({
  "node_modules/@datastructures-js/graph/node_modules/@datastructures-js/queue/src/queue.js"(exports, module) {
    var Queue = class {
      /**
       * Creates a queue.
       * @param {array} [elements]
       */
      constructor(elements) {
        this._elements = Array.isArray(elements) ? elements : [];
        this._offset = 0;
      }
      /**
       * Adds an element at the back of the queue.
       * @public
       * @param {any} element
       */
      enqueue(element) {
        this._elements.push(element);
      }
      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {any}
       */
      dequeue() {
        if (this.size() === 0)
          return null;
        const first = this.front();
        this._offset += 1;
        if (this._offset * 2 < this._elements.length)
          return first;
        this._elements = this._elements.slice(this._offset);
        this._offset = 0;
        return first;
      }
      /**
       * Returns the front element of the queue.
       * @public
       * @returns {any}
       */
      front() {
        return this.size() > 0 ? this._elements[this._offset] : null;
      }
      /**
       * Returns the back element of the queue.
       * @public
       * @returns {any}
       */
      back() {
        return this.size() > 0 ? this._elements[this._elements.length - 1] : null;
      }
      /**
       * Returns the number of elements in the queue.
       * @public
       * @returns {number}
       */
      size() {
        return this._elements.length - this._offset;
      }
      /**
       * Checks if the queue is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }
      /**
       * Returns the remaining elements in the queue as an array.
       * @public
       * @returns {array}
       */
      toArray() {
        return this._elements.slice(this._offset);
      }
      /**
       * Clears the queue.
       * @public
       */
      clear() {
        this._elements = [];
        this._offset = 0;
      }
      /**
       * Creates a shallow copy of the queue.
       * @public
       * @return {Queue}
       */
      clone() {
        return new Queue(this._elements.slice(this._offset));
      }
      /**
       * Creates a queue from an existing array.
       * @public
       * @static
       * @param {array} elements
       * @return {Queue}
       */
      static fromArray(elements) {
        return new Queue(elements);
      }
    };
    module.exports = Queue;
  }
});

// node_modules/@datastructures-js/graph/node_modules/@datastructures-js/queue/index.js
var require_queue4 = __commonJS({
  "node_modules/@datastructures-js/graph/node_modules/@datastructures-js/queue/index.js"(exports, module) {
    var Queue = require_queue3();
    module.exports = Queue;
  }
});

// node_modules/@datastructures-js/graph/src/directedGraph.js
var require_directedGraph = __commonJS({
  "node_modules/@datastructures-js/graph/src/directedGraph.js"(exports) {
    var Queue = require_queue4();
    var DirectedGraph = class {
      constructor() {
        this._vertices = /* @__PURE__ */ new Map();
        this._edges = /* @__PURE__ */ new Map();
        this._edgesCount = 0;
      }
      /**
       * Adds a vertex to the graph
       * @public
       * @param {number|string} key
       * @param {object} value
       * @return {DirectedGraph}
       */
      addVertex(key, value) {
        this._vertices.set(key, value);
        if (!this._edges.has(key)) {
          this._edges.set(key, /* @__PURE__ */ new Map());
        }
        return this;
      }
      /**
       * Checks if the graph has a vertex
       * @public
       * @param {number|string} key
       * @return {boolean}
       */
      hasVertex(key) {
        return this._vertices.has(key);
      }
      /**
       * returns vertex value
       * @public
       * @param {number|string} key
       * @return {object}
       */
      getVertexValue(key) {
        return this._vertices.get(key);
      }
      /**
       * Removes a vertex and all its edges from the graph
       * @public
       * @param {number|string} key
       * @return {boolean}
       */
      removeVertex(key) {
        if (!this.hasVertex(key))
          return false;
        this.removeEdges(key);
        this._edges.delete(key);
        this._vertices.delete(key);
        return true;
      }
      /**
       * Returns the number of vertices in the graph
       * @public
       * @return {number}
       */
      getVerticesCount() {
        return this._vertices.size;
      }
      /**
       * Returns the vertices connected to a given vertex
       * @public
       * @return {array}
       */
      getConnectedVertices(key) {
        if (!this._edges.has(key))
          return [];
        const result = [];
        this._edges.get(key).forEach((w, k) => result.push(k));
        return result;
      }
      /**
       * Returns the edges connected to a given vertex
       * @public
       * @return {object}
       */
      getConnectedEdges(key) {
        if (!this._edges.has(key))
          return {};
        const result = {};
        this._edges.get(key).forEach((w, k) => {
          result[k] = w;
        });
        return result;
      }
      /**
       * Adds a directed edge from a source vertex to a destination
       * @public
       * @param {number|string} srcKey
       * @param {number|string} destKey
       * @param {number} [weight] - default 1
       */
      addEdge(srcKey, destKey, weight) {
        if (!this._vertices.has(srcKey)) {
          throw new Error(`addEdge: vertex "${srcKey}" not found`);
        }
        if (!this._vertices.has(destKey)) {
          throw new Error(`addEdge: vertex "${destKey}" not found`);
        }
        if (weight && Number.isNaN(+weight)) {
          throw new Error("addEdge: expects a numberic weight");
        }
        const w = Number.isNaN(+weight) ? 1 : +weight;
        this._edges.get(srcKey).set(destKey, w);
        this._edgesCount += 1;
        return this;
      }
      /**
       * Checks if there is a direction between two nodes
       * @public
       * @param {number|string} srcKey
       * @param {number|string} destKey
       * @returns {boolean}
       */
      hasEdge(srcKey, destKey) {
        return this.hasVertex(srcKey) && this.hasVertex(destKey) && this._edges.get(srcKey).has(destKey);
      }
      /**
       * Gets the weight of an edge if exists
       * @public
       * @param {number|string} srcKey
       * @param {number|string} destKey
       * @returns {number}
       */
      getWeight(srcKey, destKey) {
        if (this.hasVertex(srcKey) && srcKey === destKey) {
          return 0;
        }
        if (!this.hasEdge(srcKey, destKey)) {
          return Infinity;
        }
        return this._edges.get(srcKey).get(destKey);
      }
      /**
       * Removes the direction from source to destination
       * @public
       * @param {number|string} srcKey
       * @param {number|string} destKey
       */
      removeEdge(srcKey, destKey) {
        if (!this.hasEdge(srcKey, destKey)) {
          return false;
        }
        this._edges.get(srcKey).delete(destKey);
        this._edgesCount -= 1;
        return true;
      }
      /**
       * Removes in and out directions of a vertex
       * @public
       * @param {number|string} key
       * @return {number} number of removed edges
       */
      removeEdges(key) {
        if (!this.hasVertex(key)) {
          return 0;
        }
        let removedEdgesCount = 0;
        this._edges.forEach((destEdges, srcKey) => {
          if (destEdges.has(key)) {
            this.removeEdge(srcKey, key);
            removedEdgesCount += 1;
          }
        });
        removedEdgesCount += this._edges.get(key).size;
        this._edgesCount -= this._edges.get(key).size;
        this._edges.set(key, /* @__PURE__ */ new Map());
        return removedEdgesCount;
      }
      /**
       * Returns the number of edges in the graph
       * @public
       * @returns {number}
       */
      getEdgesCount() {
        return this._edgesCount;
      }
      /**
       * Traverse all vertices in the graph using depth-first search
       * @public
       * @param {number|string} srcKey - starting node
       * @param {function} cb
       * @param {function} abortCb
       */
      traverseDfs(srcKey, cb, abortCb) {
        const traverseDfsRecursive = (key, visited = /* @__PURE__ */ new Set()) => {
          if (!this.hasVertex(key) || visited.has(key) || abortCb && abortCb()) {
            return;
          }
          cb(key, this._vertices.get(key));
          visited.add(key);
          this._edges.get(key).forEach((weight, destKey) => {
            traverseDfsRecursive(destKey, visited);
          });
        };
        traverseDfsRecursive(srcKey);
      }
      /**
       * Traverse all vertices in the graph using breadth-first search
       * @public
       * @param {number|string} srcKey - starting node
       * @param {function} cb
       * @param {function} abortCb
       */
      traverseBfs(srcKey, cb, abortCb) {
        if (!this.hasVertex(srcKey))
          return;
        const queue = new Queue([srcKey]);
        const visited = /* @__PURE__ */ new Set([srcKey]);
        while (!queue.isEmpty() && (!abortCb || !abortCb())) {
          const nextKey = queue.dequeue();
          cb(nextKey, this._vertices.get(nextKey));
          this._edges.get(nextKey).forEach((weight, destKey) => {
            if (!visited.has(destKey)) {
              queue.enqueue(destKey);
              visited.add(destKey);
            }
          });
        }
      }
      /**
       * Clears the graph
       * @public
       */
      clear() {
        this._vertices = /* @__PURE__ */ new Map();
        this._edges = /* @__PURE__ */ new Map();
        this._edgesCount = 0;
      }
    };
    exports.DirectedGraph = DirectedGraph;
  }
});

// node_modules/@datastructures-js/graph/src/graph.js
var require_graph = __commonJS({
  "node_modules/@datastructures-js/graph/src/graph.js"(exports) {
    var { DirectedGraph } = require_directedGraph();
    var Graph = class extends DirectedGraph {
      /**
       * Removes all edges connected to a vertex
       * @public
       * @override
       * @param {number|string} key
       * @return {number} number of removedEdgesCount edges
       */
      removeEdges(key) {
        if (!this.hasVertex(key)) {
          return 0;
        }
        let removedEdgesCount = 0;
        this._edges.get(key).forEach((weight, destKey) => {
          this.removeEdge(destKey, key);
          removedEdgesCount += 1;
        });
        this._edgesCount -= this._edges.get(key).size;
        this._edges.set(key, /* @__PURE__ */ new Map());
        return removedEdgesCount;
      }
      /**
       * Adds an edge between two existing vertices
       * @public
       * @override
       * @param {number|string} srcKey
       * @param {number|string} destKey
       * @param {number} [weight] - default 1
       */
      addEdge(sourceKey, destKey, weight) {
        super.addEdge(sourceKey, destKey, weight);
        return super.addEdge(destKey, sourceKey, weight);
      }
      /**
       * Removes the connecting edge between two vertices
       * @public
       * @override
       * @param {number|string} srcKey
       * @param {number|string} destKey
       * @returns {boolean}
       */
      removeEdge(sourceKey, destKey) {
        super.removeEdge(sourceKey, destKey);
        return super.removeEdge(destKey, sourceKey);
      }
      /**
       * Gets the number of edges in the graph
       * @public
       * @override
       * @returns {number}
       */
      getEdgesCount() {
        return super.getEdgesCount() / 2;
      }
    };
    exports.Graph = Graph;
  }
});

// node_modules/@datastructures-js/graph/index.js
var require_graph2 = __commonJS({
  "node_modules/@datastructures-js/graph/index.js"(exports) {
    var { Graph } = require_graph();
    var { DirectedGraph } = require_directedGraph();
    exports.Graph = Graph;
    exports.DirectedGraph = DirectedGraph;
  }
});

// node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js
var require_binarySearchTreeNode = __commonJS({
  "node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js"(exports) {
    var BinarySearchTreeNode = class {
      constructor(value) {
        this._value = value;
        this._left = null;
        this._right = null;
        this._parent = null;
      }
      /**
       * @public
       * @param {number|string|object} value
       * @returns {BinarySearchTreeNode}
       */
      setValue(value) {
        this._value = value;
        return this;
      }
      /**
       * @public
       * @return {number|string|object}
       */
      getValue() {
        return this._value;
      }
      /**
       * @public
       * @param {BinarySearchTreeNode} left
       * @returns {BinarySearchTreeNode}
       */
      setLeft(left) {
        if (left && !(left instanceof BinarySearchTreeNode)) {
          throw new Error("setLeft expects a BinarySearchTreeNode");
        }
        this._left = left || null;
        return this;
      }
      /**
       * @public
       * @return {BinarySearchTreeNode}
       */
      getLeft() {
        return this._left;
      }
      /**
       * @public
       * @return {boolean}
       */
      hasLeft() {
        return this._left instanceof BinarySearchTreeNode;
      }
      /**
       * @public
       * @param {BinarySearchTreeNode|null} right
       * @returns {BinarySearchTreeNode}
       */
      setRight(right) {
        if (right && !(right instanceof BinarySearchTreeNode)) {
          throw new Error("setRight expects a BinarySearchTreeNode or null");
        }
        this._right = right || null;
        return this;
      }
      /**
       * @public
       * @return {BinarySearchTreeNode}
       */
      getRight() {
        return this._right;
      }
      /**
       * @public
       * @return {boolean}
       */
      hasRight() {
        return this._right instanceof BinarySearchTreeNode;
      }
      /**
       * @public
       * @param {BinarySearchTreeNode} parent
       * @returns {BinarySearchTreeNode}
       */
      setParent(parent) {
        if (parent && !(parent instanceof BinarySearchTreeNode)) {
          throw new Error("setParent expects a BinarySearchTreeNode or null");
        }
        this._parent = parent || null;
        return this;
      }
      /**
       * @public
       * @return {BinarySearchTreeNode}
       */
      getParent() {
        return this._parent;
      }
      /**
       * @public
       * @return {boolean}
       */
      hasParent() {
        return this._parent instanceof BinarySearchTreeNode;
      }
      /**
       * @public
       * @return {boolean}
       */
      isRoot() {
        return this._parent === null;
      }
      /**
       * @public
       * @return {boolean}
       */
      isLeaf() {
        return !this.hasLeft() && !this.hasRight();
      }
    };
    exports.BinarySearchTreeNode = BinarySearchTreeNode;
  }
});

// node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js
var require_binarySearchTree = __commonJS({
  "node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js"(exports) {
    var { BinarySearchTreeNode } = require_binarySearchTreeNode();
    var defaultCompare = (a, b) => {
      if (a === b)
        return 0;
      return a > b ? 1 : -1;
    };
    var BinarySearchTree = class {
      constructor(compare, options) {
        if (compare && typeof compare !== "function") {
          throw new Error("BinarySearchTree constructor expects a compare function");
        }
        this._compare = compare || defaultCompare;
        this._options = options || {};
        this._root = null;
        this._count = 0;
      }
      /**
       * Inserts a node with a key/value into the tree
       * @public
       * @param {number|string|object} value
       * @return {BinarySearchTree}
       */
      insert(value) {
        const newNode = new BinarySearchTreeNode(value);
        const insertRecursive = (current) => {
          const compare = this._compare(newNode.getValue(), current.getValue());
          if (compare < 0) {
            if (current.hasLeft()) {
              insertRecursive(current.getLeft());
            } else {
              current.setLeft(newNode.setParent(current));
              this._count += 1;
            }
          } else if (compare > 0) {
            if (current.hasRight()) {
              insertRecursive(current.getRight());
            } else {
              current.setRight(newNode.setParent(current));
              this._count += 1;
            }
          } else {
            current.setValue(value);
          }
        };
        if (this._root === null) {
          this._root = newNode;
          this._count += 1;
        } else {
          insertRecursive(this._root);
        }
        return this;
      }
      /**
       * Checks if a value exists in the tree by its value
       * @public
       * @param {number|string|object} value
       * @return {boolean}
       */
      has(value) {
        const hasRecursive = (current) => {
          if (current === null)
            return false;
          const compare = this._compare(value, current.getValue());
          if (compare === 0)
            return true;
          if (compare < 0)
            return hasRecursive(current.getLeft());
          return hasRecursive(current.getRight());
        };
        return hasRecursive(this._root);
      }
      /**
       * Checks if a value exists in the tree by its key
       * @public
       * @param {number|string} key
       * @return {boolean}
       */
      hasKey(key) {
        if (this._options.key === void 0 || this._options.key === null) {
          throw new Error("Missing key prop name in constructor options");
        }
        return this.has({ [this._options.key]: key });
      }
      /**
       * Finds a node by its value
       * @public
       * @param {number|string|object} value
       * @return {BinarySearchTreeNode}
       */
      find(value) {
        const findRecursive = (current) => {
          if (current === null)
            return null;
          const compare = this._compare(value, current.getValue());
          if (compare === 0)
            return current;
          if (compare < 0)
            return findRecursive(current.getLeft());
          return findRecursive(current.getRight());
        };
        return findRecursive(this._root);
      }
      /**
       * Finds a node by its object's key
       * @public
       * @param {number|string} key
       * @return {BinarySearchTreeNode}
       */
      findKey(key) {
        if (this._options.key === void 0 || this._options.key === null) {
          throw new Error("Missing key prop name in constructor options");
        }
        return this.find({ [this._options.key]: key });
      }
      /**
       * Finds the node with max key (most right) in the tree
       * @public
       * @param {BinarySearchTreeNode} [current]
       * @return {BinarySearchTreeNode}
       */
      max(current = this._root) {
        if (current === null)
          return null;
        if (current.hasRight())
          return this.max(current.getRight());
        return current;
      }
      /**
       * Finds the node with min key (most left) in the tree
       * @public
       * @param {BinarySearchTreeNode} [current]
       * @return {BinarySearchTreeNode}
       */
      min(current = this._root) {
        if (current === null)
          return null;
        if (current.hasLeft())
          return this.min(current.getLeft());
        return current;
      }
      /**
       * Returns the node with the biggest value less or equal a given value
       * @public
       * @param {number|string|object} value
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      lowerBound(value, includeEqual = true) {
        let lowerBound = null;
        const lowerBoundRecursive = (current) => {
          if (current === null)
            return lowerBound;
          const compare = this._compare(value, current.getValue());
          if (compare > 0 || includeEqual && compare === 0) {
            if (lowerBound === null || this._compare(lowerBound.getValue(), current.getValue()) <= 0) {
              lowerBound = current;
            }
            return lowerBoundRecursive(current.getRight());
          }
          return lowerBoundRecursive(current.getLeft());
        };
        return lowerBoundRecursive(this._root);
      }
      /**
       * Returns the node with the biggest object's key less or equal a given key
       * @public
       * @param {number|string} key
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      lowerBoundKey(key, includeEqual = true) {
        if (this._options.key === void 0 || this._options.key === null) {
          throw new Error("Missing key prop name in constructor options");
        }
        return this.lowerBound({ [this._options.key]: key }, includeEqual);
      }
      /**
       * Returns the node with the biggest value less or equal a given value
       * @public
       * @param {number|string|object} value
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      floor(value, includeEqual = true) {
        return this.lowerBound(value, includeEqual);
      }
      /**
       * Returns the node with the biggest object's key less or equal a given value
       * @public
       * @param {number|string} value
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      floorKey(key, includeEqual = true) {
        return this.lowerBoundKey(key, includeEqual);
      }
      /**
       * Returns the node with the smallest value greater or equal a given value
       * @public
       * @param {number|string|object} value
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      upperBound(value, includeEqual = true) {
        let upperBound = null;
        const upperBoundRecursive = (current) => {
          if (current === null)
            return upperBound;
          const compare = this._compare(value, current.getValue());
          if (compare < 0 || includeEqual && compare === 0) {
            if (upperBound === null || this._compare(upperBound.getValue(), current.getValue()) >= 0) {
              upperBound = current;
            }
            return upperBoundRecursive(current.getLeft());
          }
          return upperBoundRecursive(current.getRight());
        };
        return upperBoundRecursive(this._root);
      }
      /**
       * Returns the node with the smallest object's key greater or equal a given key
       * @public
       * @param {number|string} key
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      upperBoundKey(key, includeEqual = true) {
        if (this._options.key === void 0 || this._options.key === null) {
          throw new Error("Missing key prop name in constructor options");
        }
        return this.upperBound({ [this._options.key]: key }, includeEqual);
      }
      /**
       * Returns the node with the smallest value greater or equal a given value
       * @public
       * @param {number|string|object} value
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      ceil(value, includeEqual = true) {
        return this.upperBound(value, includeEqual);
      }
      /**
       * Returns the node with the smallest object's key greater or equal a given key
       * @public
       * @param {number|string} key
       * @param {boolean} includeEqual
       * @return {BinarySearchTreeNode|null}
       */
      ceilKey(key, includeEqual = true) {
        return this.upperBoundKey(key, includeEqual);
      }
      /**
       * Returns the root node
       * @public
       * @return {BinarySearchTreeNode}
       */
      root() {
        return this._root;
      }
      /**
       * Returns the nodes count
       * @public
       * @return {number}
       */
      count() {
        return this._count;
      }
      /**
       * Removes a node by its value
       * @public
       * @param {number|string|object} value
       * @return {boolean}
       */
      remove(value) {
        const removeRecursively = (val, current) => {
          if (current === null)
            return false;
          const compare = this._compare(val, current.getValue());
          if (compare < 0)
            return removeRecursively(val, current.getLeft());
          if (compare > 0)
            return removeRecursively(val, current.getRight());
          return this.removeNode(current);
        };
        return removeRecursively(value, this._root);
      }
      /**
       * Removes a node from the tree
       * @public
       * @param {BinarySearchTreeNode} node
       * @return {boolean}
       */
      removeNode(node) {
        if (node === null || !(node instanceof BinarySearchTreeNode)) {
          return false;
        }
        if (node.isLeaf()) {
          if (node.isRoot()) {
            this._root = null;
          } else if (this._compare(node.getValue(), node.getParent().getValue()) < 0) {
            node.getParent().setLeft(null);
          } else {
            node.getParent().setRight(null);
          }
          this._count -= 1;
          return true;
        }
        if (!node.hasRight()) {
          if (node.isRoot()) {
            this._root = node.getLeft();
          } else if (this._compare(node.getValue(), node.getParent().getValue()) < 0) {
            node.getParent().setLeft(node.getLeft());
          } else {
            node.getParent().setRight(node.getLeft());
          }
          node.getLeft().setParent(node.getParent());
          this._count -= 1;
          return true;
        }
        if (!node.hasLeft()) {
          if (node.isRoot()) {
            this._root = node.getRight();
          } else if (this._compare(node.getValue(), node.getParent().getValue()) < 0) {
            node.getParent().setLeft(node.getRight());
          } else {
            node.getParent().setRight(node.getRight());
          }
          node.getRight().setParent(node.getParent());
          this._count -= 1;
          return true;
        }
        const minRight = this.min(node.getRight());
        node.setValue(minRight.getValue());
        return this.removeNode(minRight);
      }
      /**
       * Traverses the tree in-order (left-node-right)
       * @public
       * @param {function} cb
       * @param {function} [abortCb]
       */
      traverseInOrder(cb, abortCb) {
        if (typeof cb !== "function") {
          throw new Error(".traverseInOrder expects a callback function");
        }
        const traverseRecursive = (current) => {
          if (current === null || abortCb && abortCb())
            return;
          traverseRecursive(current.getLeft());
          if (abortCb && abortCb())
            return;
          cb(current);
          traverseRecursive(current.getRight());
        };
        traverseRecursive(this._root);
      }
      /**
       * Traverses the tree pre-order (node-left-right)
       * @public
       * @param {function} cb
       * @param {function} [abortCb]
       */
      traversePreOrder(cb, abortCb) {
        if (typeof cb !== "function") {
          throw new Error(".traversePreOrder expects a callback function");
        }
        const traverseRecursive = (current) => {
          if (current === null || abortCb && abortCb())
            return;
          cb(current);
          traverseRecursive(current.getLeft());
          traverseRecursive(current.getRight());
        };
        traverseRecursive(this._root);
      }
      /**
       * Traverses the tree post-order (left-right-node)
       * @public
       * @param {function} cb
       * @param {function} [abortCb]
       */
      traversePostOrder(cb, abortCb) {
        if (typeof cb !== "function") {
          throw new Error(".traversePostOrder expects a callback function");
        }
        const traverseRecursive = (current) => {
          if (current === null || abortCb && abortCb())
            return;
          traverseRecursive(current.getLeft());
          traverseRecursive(current.getRight());
          if (abortCb && abortCb())
            return;
          cb(current);
        };
        traverseRecursive(this._root);
      }
      /**
       * Clears the tree
       * @public
       */
      clear() {
        this._root = null;
        this._count = 0;
      }
    };
    exports.BinarySearchTree = BinarySearchTree;
  }
});

// node_modules/@datastructures-js/binary-search-tree/src/avlTreeNode.js
var require_avlTreeNode = __commonJS({
  "node_modules/@datastructures-js/binary-search-tree/src/avlTreeNode.js"(exports) {
    var defaultCompare = (a, b) => {
      if (a === b)
        return 0;
      return a > b ? 1 : -1;
    };
    var AvlTreeNode = class {
      constructor(value, compare) {
        if (compare && typeof compare !== "function") {
          throw new Error("AvlTreeNode constructor expects a compare function");
        }
        this._value = value;
        this._compare = compare || defaultCompare;
        this._left = null;
        this._right = null;
        this._parent = null;
        this._height = 1;
      }
      /**
       * @public
       * @param {number|string|object} value
       * @returns {AvlTreeNode}
       */
      setValue(value) {
        this._value = value;
        return this;
      }
      /**
       * @public
       * @return {number|string|object}
       */
      getValue() {
        return this._value;
      }
      /**
       * @public
       * @param {AvlTreeNode} left
       * @returns {AvlTreeNode}
       */
      setLeft(left) {
        if (left && !(left instanceof AvlTreeNode)) {
          throw new Error("setLeft expects an AvlTreeNode");
        }
        this._left = left || null;
        return this;
      }
      /**
       * @public
       * @return {AvlTreeNode}
       */
      getLeft() {
        return this._left;
      }
      /**
       * @public
       * @return {boolean}
       */
      hasLeft() {
        return this._left instanceof AvlTreeNode;
      }
      /**
       * @public
       * @param {AvlTreeNode} right
       * @returns {AvlTreeNode}
       */
      setRight(right) {
        if (right && !(right instanceof AvlTreeNode)) {
          throw new Error("setRight expects a AvlTreeNode or null");
        }
        this._right = right || null;
        return this;
      }
      /**
       * @public
       * @return {AvlTreeNode}
       */
      getRight() {
        return this._right;
      }
      /**
       * @public
       * @return {boolean}
       */
      hasRight() {
        return this._right instanceof AvlTreeNode;
      }
      /**
       * @public
       * @param {AvlTreeNode} parent
       * @returns {AvlTreeNode}
       */
      setParent(parent) {
        if (parent && !(parent instanceof AvlTreeNode)) {
          throw new Error("setParent expects an AvlTreeNode");
        }
        this._parent = parent || null;
        return this;
      }
      /**
       * @public
       * @return {AvlTreeNode}
       */
      getParent() {
        return this._parent;
      }
      /**
       * @public
       * @return {boolean}
       */
      hasParent() {
        return this._parent instanceof AvlTreeNode;
      }
      /**
       * @public
       * @return {boolean}
       */
      isRoot() {
        return this._parent === null;
      }
      /**
       * @public
       * @return {boolean}
       */
      isLeaf() {
        return !this.hasLeft() && !this.hasRight();
      }
      /**
       * Rotate-self left (counter-clockwise)
       * @public
       * @returns {AvlTreeNode}
       */
      rotateLeft() {
        const right = this._right;
        if (right !== null) {
          if (right.hasLeft()) {
            right.getLeft().setParent(this);
          }
          this._right = right.getLeft();
          right.setLeft(this);
          right.setParent(this._parent);
        }
        if (this.hasParent() && right !== null) {
          if (this._compare(this._parent.getValue(), right.getValue()) < 0) {
            this._parent.setRight(right);
          } else {
            this._parent.setLeft(right);
          }
        }
        this._parent = right;
        this.updateHeight();
        if (this.hasParent()) {
          this._parent.updateHeight();
        }
        return this;
      }
      /**
       * Rotate-self right (clockwise)
       * @public
       * @returns {AvlTreeNode}
       */
      rotateRight() {
        const left = this._left;
        if (left !== null) {
          if (left.hasRight()) {
            left.getRight().setParent(this);
          }
          this._left = left.getRight();
          left.setRight(this);
          left.setParent(this._parent);
        }
        if (this.hasParent() && left !== null) {
          if (this._compare(this._parent.getValue(), left.getValue()) > 0) {
            this._parent.setLeft(left);
          } else {
            this._parent.setRight(left);
          }
        }
        this._parent = left;
        this.updateHeight();
        if (this.hasParent()) {
          this._parent.updateHeight();
        }
        return this;
      }
      /**
       * Rotate-self to right after rotating left child to left
       * @public
       * @returns {AvlTreeNode}
       */
      rotateLeftRight() {
        if (this.hasLeft()) {
          this._left.rotateLeft();
        }
        this.rotateRight();
        return this;
      }
      /**
       * Rotate-self to left after rotating right child to right
       * @public
       * @returns {AvlTreeNode}
       */
      rotateRightLeft() {
        if (this.hasRight()) {
          this._right.rotateRight();
        }
        this.rotateLeft();
        return this;
      }
      /**
       * @public
       * @return {number}
       */
      getLeftHeight() {
        return this.hasLeft() ? this.getLeft().getHeight() : 0;
      }
      /**
       * @public
       * @return {number}
       */
      getRightHeight() {
        return this.hasRight() ? this.getRight().getHeight() : 0;
      }
      /**
       * Updates self height based on the max height of children
       * @public
       * @returns {AvlTreeNode}
      */
      updateHeight() {
        this._height = Math.max(this.getLeftHeight(), this.getRightHeight()) + 1;
        return this;
      }
      /**
       * @public
       * @return {number}
       */
      getHeight() {
        return this._height;
      }
      /**
       * Gets the balance of a node as the diff between left & right heights
       * @public
       * @return {number}
       */
      getBalance() {
        return this.getLeftHeight() - this.getRightHeight();
      }
      /**
       * Checks if the node is balanced
       * @public
       * @return {boolean}
       */
      isBalanced() {
        const balance = this.getBalance();
        return balance >= -1 && balance <= 1;
      }
    };
    exports.AvlTreeNode = AvlTreeNode;
  }
});

// node_modules/@datastructures-js/binary-search-tree/src/avlTree.js
var require_avlTree = __commonJS({
  "node_modules/@datastructures-js/binary-search-tree/src/avlTree.js"(exports) {
    var { BinarySearchTree } = require_binarySearchTree();
    var { AvlTreeNode } = require_avlTreeNode();
    var AvlTree = class extends BinarySearchTree {
      constructor(compare, options) {
        if (compare && typeof compare !== "function") {
          throw new Error("AvlTree constructor expects a compare function");
        }
        super(compare, options);
      }
      /**
       * Applies the proper rotation on a node
       * @private
       * @param {AvlTreeNode} node
       */
      _balanceNode(node) {
        if (!node)
          return;
        node.updateHeight();
        const balance = node.getBalance();
        if (balance > 1) {
          if (node.getLeft().hasLeft()) {
            node.rotateRight();
          } else if (node.getLeft().hasRight()) {
            node.rotateLeftRight();
          }
        } else if (balance < -1) {
          if (node.getRight().hasRight()) {
            node.rotateLeft();
          } else if (node.getRight().hasLeft()) {
            node.rotateRightLeft();
          }
        }
        if ((balance < -1 || balance > 1) && node === this._root) {
          this._root = node.getParent();
        }
      }
      /**
       * Inserts a value into the tree and maintains
       * the tree balanced by making the necessary rotations
       *
       * @public
       * @param {number|string|object} value
       * @return {AvlTree}
       */
      insert(value) {
        const newNode = new AvlTreeNode(value, this._compare);
        const insertRecursive = (current) => {
          const compare = this._compare(value, current.getValue());
          if (compare < 0) {
            if (current.hasLeft()) {
              insertRecursive(current.getLeft());
              this._balanceNode(current);
            } else {
              newNode.setParent(current);
              current.setLeft(newNode).updateHeight();
              this._count += 1;
            }
          } else if (compare > 0) {
            if (current.hasRight()) {
              insertRecursive(current.getRight());
              this._balanceNode(current);
            } else {
              newNode.setParent(current);
              current.setRight(newNode).updateHeight();
              this._count += 1;
            }
          } else {
            current.setValue(value);
          }
        };
        if (this._root === null) {
          this._root = newNode;
          this._count += 1;
        } else {
          insertRecursive(this._root);
        }
        return this;
      }
      /**
       * Removes a node from the tree and maintains
       * the tree balanced by making the necessary rotations
       *
       * @public
       * @param {number|string|object} value
       * @return {boolean}
       */
      remove(value) {
        const removeRecursively = (val, current) => {
          if (current === null) {
            return false;
          }
          const compare = this._compare(val, current.getValue());
          if (compare < 0) {
            const removed = removeRecursively(val, current.getLeft());
            this._balanceNode(current);
            return removed;
          }
          if (compare > 0) {
            const removed = removeRecursively(val, current.getRight());
            this._balanceNode(current);
            return removed;
          }
          return this.removeNode(current);
        };
        return removeRecursively(value, this._root);
      }
      /**
       * Removes a node from the tree
       * @public
       * @param {AvlTreeNode} node
       * @return {boolean}
       */
      removeNode(node) {
        if (node === null || !(node instanceof AvlTreeNode)) {
          return false;
        }
        if (node.isLeaf()) {
          if (node.isRoot()) {
            this._root = null;
          } else if (this._compare(node.getValue(), node.getParent().getValue()) < 0) {
            node.getParent().setLeft(null).updateHeight();
          } else {
            node.getParent().setRight(null).updateHeight();
          }
          this._count -= 1;
          return true;
        }
        if (!node.hasRight()) {
          if (node.isRoot()) {
            this._root = node.getLeft();
          } else if (this._compare(node.getValue(), node.getParent().getValue()) < 0) {
            node.getParent().setLeft(node.getLeft()).updateHeight();
          } else {
            node.getParent().setRight(node.getLeft()).updateHeight();
          }
          node.getLeft().setParent(node.getParent());
          this._count -= 1;
          return true;
        }
        if (!node.hasLeft()) {
          if (node.isRoot()) {
            this._root = node.getRight();
          } else if (this._compare(node.getValue(), node.getParent().getValue()) < 0) {
            node.getParent().setLeft(node.getRight()).updateHeight();
          } else {
            node.getParent().setRight(node.getRight()).updateHeight();
          }
          node.getRight().setParent(node.getParent());
          this._count -= 1;
          return true;
        }
        const minRight = this.min(node.getRight());
        const removed = this.removeNode(minRight);
        node.setValue(minRight.getValue());
        this._balanceNode(node);
        return removed;
      }
    };
    exports.AvlTree = AvlTree;
  }
});

// node_modules/@datastructures-js/binary-search-tree/index.js
var require_binary_search_tree = __commonJS({
  "node_modules/@datastructures-js/binary-search-tree/index.js"(exports, module) {
    var { BinarySearchTree } = require_binarySearchTree();
    var { BinarySearchTreeNode } = require_binarySearchTreeNode();
    var { AvlTree } = require_avlTree();
    var { AvlTreeNode } = require_avlTreeNode();
    module.exports = {
      BinarySearchTree,
      BinarySearchTreeNode,
      AvlTree,
      AvlTreeNode
    };
  }
});

// node_modules/datastructures-js/index.js
var require_datastructures_js = __commonJS({
  "node_modules/datastructures-js/index.js"(exports) {
    var { Queue } = require_queue2();
    var { Stack } = require_stack2();
    var { Deque } = require_deque2();
    var {
      PriorityQueue,
      MinPriorityQueue,
      MaxPriorityQueue
    } = require_priority_queue();
    var { Heap, MinHeap, MaxHeap } = require_heap2();
    var { EnhancedSet } = require_set();
    var {
      LinkedList,
      LinkedListNode,
      DoublyLinkedList,
      DoublyLinkedListNode
    } = require_linked_list();
    var { Trie, TrieNode } = require_trie2();
    var { Graph, DirectedGraph } = require_graph2();
    var {
      BinarySearchTree,
      BinarySearchTreeNode,
      AvlTree,
      AvlTreeNode
    } = require_binary_search_tree();
    exports.Queue = Queue;
    exports.Stack = Stack;
    exports.Deque = Deque;
    exports.PriorityQueue = PriorityQueue;
    exports.MinPriorityQueue = MinPriorityQueue;
    exports.MaxPriorityQueue = MaxPriorityQueue;
    exports.Heap = Heap;
    exports.MinHeap = MinHeap;
    exports.MaxHeap = MaxHeap;
    exports.EnhancedSet = EnhancedSet;
    exports.LinkedList = LinkedList;
    exports.LinkedListNode = LinkedListNode;
    exports.DoublyLinkedList = DoublyLinkedList;
    exports.DoublyLinkedListNode = DoublyLinkedListNode;
    exports.Trie = Trie;
    exports.TrieNode = TrieNode;
    exports.Graph = Graph;
    exports.DirectedGraph = DirectedGraph;
    exports.BinarySearchTree = BinarySearchTree;
    exports.BinarySearchTreeNode = BinarySearchTreeNode;
    exports.AvlTree = AvlTree;
    exports.AvlTreeNode = AvlTreeNode;
  }
});
export default require_datastructures_js();
/*! Bundled license information:

@datastructures-js/queue/src/queue.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   *)

@datastructures-js/stack/src/stack.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   *)

@datastructures-js/deque/src/deque.js:
  (**
   * @license MIT
   * @copyright 2022 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   * double-ended queue
   *)

@datastructures-js/heap/src/heap.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   *)

@datastructures-js/heap/src/minHeap.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *)

@datastructures-js/heap/src/maxHeap.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *)

@datastructures-js/priority-queue/src/minPriorityQueue.js:
  (**
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/priority-queue/src/maxPriorityQueue.js:
  (**
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/priority-queue/src/priorityQueue.js:
  (**
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/set/src/enhancedSet.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   * @extends Set - ES6 global Set https://mzl.la/2QajnHr
   *)

@datastructures-js/linked-list/src/linkedListNode.js:
  (**
   * datastructures-js/linked-list
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   *)

@datastructures-js/linked-list/src/linkedList.js:
  (**
   * datastructures-js/linked-list
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *)

@datastructures-js/linked-list/src/doublyLinkedListNode.js:
  (**
   * datastructures-js/linked-list
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/linked-list/src/doublyLinkedList.js:
  (**
   * datastructures-js/linked-list
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *)

@datastructures-js/trie/src/trieNode.js:
  (**
   * datastructures-js/trie
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *
   * @class TrieNode
   *)

@datastructures-js/trie/src/trie.js:
  (**
   * datastructures-js/trie
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/queue/src/queue.js:
  (**
   * @license MIT
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   *
   * @class
   *)

@datastructures-js/graph/src/directedGraph.js:
  (**
   * datastructures-js/graph
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/graph/src/graph.js:
  (**
   * datastructures-js/graph
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js:
  (**
   * datastructures-js/binary-search-tree
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/binary-search-tree/src/binarySearchTree.js:
  (**
   * datastructures-js/binary-search-tree
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/binary-search-tree/src/avlTreeNode.js:
  (**
   * datastructures-js/binary-search-tree
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)

@datastructures-js/binary-search-tree/src/avlTree.js:
  (**
   * datastructures-js/binary-search-tree
   * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=datastructures-js.js.map
